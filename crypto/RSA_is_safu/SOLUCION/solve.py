from Crypto.Util.number import long_to_bytes
from sympy import integer_nthroot

# Low Public Exponent Attack for RSA
n1=6148131047579288585808188402641085717538164057471718582189263534883392257121726699851020067233953739754061234448541108916627341402317380068360751896298407
c1=4927325767614507633138552822746954728674991116834017669267179091667995134458654770081452139080184524608383873636723213478146744268700356687219705275225910
n2=7514406050136763685553278064696069243466367829510292513369009439794043585430711861932262060024030593662783285674331058413022534706106485692511200714486527
c2=4188531615627305030570845702946702294361466663649993882211089192538756168251731166953265636470968333303982987087114208792046638920239436939914619535222999
n3=4990517951160704662294721793999016131925100580722019395519397759502988930281352617334696427407351659767098256805527265178698401807348321295317659062823761
c3=3278589955524716092953251954075071019588461275406222102089932626976490262704433564044772549155669025639152530296269956648339758571890747556609603306684510

# Teorema chino del resto
t1 = c1*(n2*n3)*pow(n2*n3, -1, n1)
t2 = c2*(n1*n3)*pow(n1*n3, -1, n2)
t3 = c3*(n2*n1)*pow(n2*n1, -1, n3)
c = (t1+t2+t3)%(n1*n2*n3)
m, perfect = integer_nthroot(c, 3)
assert perfect

m = long_to_bytes(m)
print(m.decode())
